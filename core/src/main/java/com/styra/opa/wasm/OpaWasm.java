package com.styra.opa.wasm;

import com.dylibso.chicory.runtime.HostFunction;
import com.dylibso.chicory.runtime.ImportMemory;
import com.dylibso.chicory.runtime.ImportValues;
import com.dylibso.chicory.runtime.Instance;
import com.dylibso.chicory.runtime.Memory;
import com.dylibso.chicory.wasm.Parser;
import com.dylibso.chicory.wasm.types.ValueType;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.InputStream;
import java.util.List;

// Low level bindings to OPA
// The resulting code is the target to be generated by chicory-bindgen
public class OpaWasm {
    private final OpaImports imports;
    private final Instance instance;
    private final ObjectMapper jsonMapper;
    private final ObjectMapper yamlMapper;

    public static Builder builder() {
        return new Builder();
    }

    private OpaWasm(
            OpaImports imports, InputStream is, ObjectMapper jsonMapper, ObjectMapper yamlMapper) {
        this.jsonMapper = jsonMapper;
        this.yamlMapper = yamlMapper;
        this.imports = imports;
        // Imports
        ImportMemory memory = new ImportMemory("env", "memory", imports.memory());
        HostFunction opaAbort =
                new HostFunction(
                        "env",
                        "opa_abort",
                        List.of(ValueType.I32),
                        List.of(),
                        (Instance instance, long... args) -> {
                            imports.opaAbort(this, (int) args[0]);
                            return null;
                        });
        HostFunction opaPrintln =
                new HostFunction(
                        "env",
                        "opa_println",
                        List.of(ValueType.I32),
                        List.of(),
                        (Instance instance, long... args) -> {
                            imports.opaPrintln(this, (int) args[0]);
                            return null;
                        });
        HostFunction opaBuiltin0 =
                new HostFunction(
                        "env",
                        "opa_builtin0",
                        List.of(ValueType.I32, ValueType.I32),
                        List.of(ValueType.I32),
                        (Instance instance, long... args) ->
                                new long[] {
                                    imports.opaBuiltin0(this, (int) args[0], (int) args[1])
                                });
        HostFunction opaBuiltin1 =
                new HostFunction(
                        "env",
                        "opa_builtin1",
                        List.of(ValueType.I32, ValueType.I32, ValueType.I32),
                        List.of(ValueType.I32),
                        (Instance instance, long... args) ->
                                new long[] {
                                    imports.opaBuiltin1(
                                            this, (int) args[0], (int) args[1], (int) args[2])
                                });
        HostFunction opaBuiltin2 =
                new HostFunction(
                        "env",
                        "opa_builtin2",
                        List.of(ValueType.I32, ValueType.I32, ValueType.I32, ValueType.I32),
                        List.of(ValueType.I32),
                        (Instance instance, long... args) ->
                                new long[] {
                                    imports.opaBuiltin2(
                                            this,
                                            (int) args[0],
                                            (int) args[1],
                                            (int) args[2],
                                            (int) args[3])
                                });
        HostFunction opaBuiltin3 =
                new HostFunction(
                        "env",
                        "opa_builtin3",
                        List.of(
                                ValueType.I32,
                                ValueType.I32,
                                ValueType.I32,
                                ValueType.I32,
                                ValueType.I32),
                        List.of(ValueType.I32),
                        (Instance instance, long... args) ->
                                new long[] {
                                    imports.opaBuiltin3(
                                            this,
                                            (int) args[0],
                                            (int) args[1],
                                            (int) args[2],
                                            (int) args[3],
                                            (int) args[4])
                                });
        HostFunction opaBuiltin4 =
                new HostFunction(
                        "env",
                        "opa_builtin4",
                        List.of(
                                ValueType.I32,
                                ValueType.I32,
                                ValueType.I32,
                                ValueType.I32,
                                ValueType.I32,
                                ValueType.I32),
                        List.of(ValueType.I32),
                        (Instance instance, long... args) ->
                                new long[] {
                                    imports.opaBuiltin4(
                                            this,
                                            (int) args[0],
                                            (int) args[1],
                                            (int) args[2],
                                            (int) args[3],
                                            (int) args[4],
                                            (int) args[5])
                                });

        instance =
                Instance.builder(Parser.parse(is))
                        .withImportValues(
                                ImportValues.builder()
                                        .addMemory(memory)
                                        .addFunction(opaAbort)
                                        .addFunction(opaPrintln)
                                        .addFunction(
                                                opaBuiltin0,
                                                opaBuiltin1,
                                                opaBuiltin2,
                                                opaBuiltin3,
                                                opaBuiltin4)
                                        .build())
                        .build();
    }

    public static class Builder {
        private OpaImports imports;
        private InputStream is;
        private ObjectMapper jsonMapper;
        private ObjectMapper yamlMapper;

        private Builder() {}

        public Builder withImports(OpaImports imports) {
            this.imports = imports;
            return this;
        }

        public Builder withInputStream(InputStream is) {
            this.is = is;
            return this;
        }

        public Builder withJsonMapper(ObjectMapper jsonMapper) {
            this.jsonMapper = jsonMapper;
            return this;
        }

        public Builder withYamlMapper(ObjectMapper yamlMapper) {
            this.yamlMapper = yamlMapper;
            return this;
        }

        public OpaWasm build() {
            return new OpaWasm(imports, is, jsonMapper, yamlMapper);
        }
    }

    public OpaImports imports() {
        return imports;
    }

    public ObjectMapper jsonMapper() {
        return jsonMapper;
    }

    public ObjectMapper yamlMapper() {
        return yamlMapper;
    }

    public Memory memory() {
        return instance.memory();
    }

    // exports
    public int opaWasmAbiVersion() {
        return (int) instance.export("opa_wasm_abi_version").apply()[0];
    }

    public int opaWasmAbiMinorVersion() {
        return (int) instance.export("opa_wasm_abi_minor_version").apply()[0];
    }

    // Exports
    /*
     * Evaluates the loaded policy with the provided evaluation context. The return value is reserved for future use.
     */
    public OpaErrorCode eval(int ctxAddr) {
        return OpaErrorCode.fromValue((int) instance.export("eval").apply(ctxAddr)[0]);
    }

    /*
     * Returns the address of a mapping of built-in function names to numeric identifiers that are required by the policy.
     */
    public int builtins() {
        return (int) instance.export("builtins").apply()[0];
    }

    /*
     * Returns the address of a mapping of entrypoints to numeric identifiers that can be selected when evaluating the policy.
     */
    public int entrypoints() {
        return (int) instance.export("entrypoints").apply()[0];
    }

    /*
     * Returns the address of a newly allocated evaluation context.
     */
    public int opaEvalCtxNew() {
        return (int) instance.export("opa_eval_ctx_new").apply()[0];
    }

    /*
     * Set the input value to use during evaluation. This must be called before each eval() call. If the input value is not set before evaluation, references to the input document result produce no results (i.e., they are undefined.)
     */
    public void opaEvalCtxSetInput(int ctxAddr, int valueAddr) {
        instance.export("opa_eval_ctx_set_input").apply(ctxAddr, valueAddr);
    }

    /*
     * Set the data value to use during evaluation. This should be called before each eval() call. If the data value is not set before evaluation, references to base data documents produce no results (i.e., they are undefined.)
     */
    public void opaEvalCtxSetData(int ctxAddr, int valueAddr) {
        instance.export("opa_eval_ctx_set_data").apply(ctxAddr, valueAddr);
    }

    /*
     * Set the data value to use during evaluation. This should be called before each eval() call. If the data value is not set before evaluation, references to base data documents produce no results (i.e., they are undefined.)
     */
    public void opaEvalCtxSetEntrypoint(int ctxAddr, int entrypointId) {
        instance.export("opa_eval_ctx_set_entrypoint").apply(ctxAddr, entrypointId);
    }

    /*
     * Get the result set produced by the evaluation process.
     */
    public int opaEvalCtxGetResult(int ctxAddr) {
        return (int) instance.export("opa_eval_ctx_get_result").apply(ctxAddr)[0];
    }

    /*
     * Allocates size bytes in the shared memory and returns the starting address.
     */
    public int opaMalloc(int capacity) {
        return (int) instance.export("opa_malloc").apply(capacity)[0];
    }

    /*
     * Free a pointer. Calls opa_abort on error.
     */
    public void opaFree(int addr) {
        instance.export("opa_free").apply(addr);
    }

    /*
     * Parses the JSON serialized value starting at str_addr of size bytes and returns the address of the parsed value. The parsed value may refer to a null, boolean, number, string, array, or object value.
     */
    public int opaJsonParse(int addr, int size) {
        return (int) instance.export("opa_json_parse").apply(addr, size)[0];
    }

    /*
     * The same as opa_json_parse except Rego set literals are supported.
     */
    public int opaValueParse(int addr, int size) {
        return (int) instance.export("opa_value_parse").apply(addr, size)[0];
    }

    /*
     * Dumps the value referred to by value_addr to a null-terminated JSON serialized string and returns the address of the start of the string. Rego sets are serialized as JSON arrays. Non-string Rego object keys are serialized as strings.
     */
    public int opaJsonDump(int addr) {
        return (int) instance.export("opa_json_dump").apply(addr)[0];
    }

    /*
     * The same as opa_json_dump except Rego sets are serialized using the literal syntax and non-string Rego object keys are not serialized as strings.
     */
    public int opaValueDump(int addr) {
        return (int) instance.export("opa_value_dump").apply(addr)[0];
    }

    /*
     * Set the heap pointer for the next evaluation.
     */
    public void opaHeapPtrSet(int addr) {
        instance.export("opa_heap_ptr_set").apply(addr);
    }

    /*
     * Set the heap pointer for the next evaluation.
     */
    public int opaHeapPtrGet() {
        return (int) instance.export("opa_heap_ptr_get").apply()[0];
    }

    /*
     * Add the value at the value_addr into the object referenced by base_value_addr at the given path. The path_value_addr must point to an array value with string keys (eg: ["a", "b", "c"]). Existing values will be updated. On success the value at value_addr is no longer owned by the caller, it will be freed with the base value. The path value must be freed by the caller after use by calling opa_value_free. (The original path string passed to opa_json_parse or opa_value_parse to create the value must be freed by calling opa_free.) If an error occurs the base value will remain unchanged. Example: base object {"a": {"b": 123}}, path ["a", "x", "y"], and value {"foo": "bar"} will yield {"a": {"b": 123, "x": {"y": {"foo": "bar"}}}}. Returns an error code (see below).
     */
    public OpaErrorCode opaValueAddPath(int baseValueAddr, int pathValueAddr, int valueAddr) {
        return OpaErrorCode.fromValue(
                (int)
                        instance.export("opa_value_add_path")
                                .apply(baseValueAddr, pathValueAddr, valueAddr)[0]);
    }

    /*
     * Remove the value from the object referenced by base_value_addr at the given path. Values removed will be freed. The path value must be freed by the caller after use by calling opa_value_free. (The original path string parsed by opa_json_parse or opa_value_parse must be released using opa_free.) The path_value_addr must point to an array value with string keys (eg: ["a", "b", "c"]). Returns an error code (see below).
     */
    public OpaErrorCode opaValueRemovePath(int baseValueAddr, int pathValueAddr) {
        return OpaErrorCode.fromValue(
                (int)
                        instance.export("opa_value_remove_path")
                                .apply(baseValueAddr, pathValueAddr)[0]);
    }

    /*
     * Free a value such as one generated by opa_value_parse or opa_json_parse reference at value_addr
     */
    public void opaValueFree(int addr) {
        instance.export("opa_value_free").apply(addr);
    }

    /*
     * Stash free heap blocks in a shadow heap to enable eval or opa_eval to allocate only blocks that it can subsequently free with a call to opa_heap_ptr_set. The caller should subsequently call opa_heap_ptr_get and store the value to save before calling opa_heap_bloks_restore
     */
    public void opaHeapBlocksStash() {
        instance.export("opa_heap_blocks_stash").apply();
    }

    /*
     * Restore heap blocks stored by opa_heap_blocks_stash to the heap. This should only be called after a opa_heap_ptr_set to the a heap pointer recorded by opa_heap_ptr_get after the previous call to opa_heap_blocks_stash.
     */
    public void opaHeapBlocksRestore() {
        instance.export("opa_heap_blocks_restore").apply();
    }

    /*
     * Drop all heap blocks saved by opa_heap_blocks_stash. This leaks memory in the VM unless the caller subsequently invokes opa_heap_ptr_set to a value taken prior to calling opa_heap_blocks_stash. (see below)
     */
    public void opaHeapBlocksClear() {
        instance.export("opa_heap_blocks_clear").apply();
    }

    /*
     * One-off policy evaluation method. Its arguments are everything needed to evaluate: entrypoint, address of data in memory, address and length of input JSON string in memory, heap address to use, and the output format (0 is JSON, 1 is “value”, i.e. serialized Rego values). The first argument is reserved for future use and must be 0. Returns the address to the serialised result value.
     */
    public void opaEval(
            int entrypointId, int data, int input, int inputLen, int heapPtr, int format) {
        if (format != 0 && format != 1) {
            throw new IllegalArgumentException("Format must be 0: JSON or 1: \"value\"");
        }
        instance.export("opa_heap_blocks_clear")
                .apply(
                        0, // reserved for future use
                        entrypointId,
                        data,
                        input,
                        inputLen,
                        heapPtr,
                        format);
    }

    // helper functions - can be written by the end user
    public String readString(int addr) {
        int resultAddr = opaJsonDump(addr);
        var resultStr = memory().readCString(resultAddr);
        opaFree(resultAddr);
        return resultStr;
    }

    public int writeResult(String result) {
        var resultStrAddr = opaMalloc(result.length());
        memory().writeCString(resultStrAddr, result);
        var resultAddr = opaJsonParse(resultStrAddr, result.length());
        opaFree(resultStrAddr);
        return resultAddr;
    }
}
